<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="AUTO" />
    <option name="maxHistorySize" value="30" />
    <histories>
      <item value="means nesting-related" />
      <item value="Metric Support" />
      <item value="Asserts that an object isn't null. If it is an AssertionError is thrown with the given message." />
      <item value="Management endpoint context-path." />
      <item value="This method executes the given closure against the RepositoryHandler for this project. The RepositoryHandler is passed to the closure as the closure's delegate." />
      <item value="Sorting a list of lists according to length of sublists" />
      <item value="length Recursive" />
      <item value="second Last Recursion" />
      <item value="last Recursive" />
      <item value="complement" />
      <item value="run Only Once Guard" />
      <item value="DIRECT" />
      <item value="Pavani Diwanji" />
      <item value="Each message is routed from one machine to * another based solely on information contained within that packet. * Multiple packets sent from one machine to another might be routed * differently, and might arrive in any order. Packet delivery is * not guaranteed." />
      <item value="connectionless" />
      <item value="represents" />
      <item value="Big Decimal" />
      <item value="Exclusive" />
      <item value="get Exclusive Owner Thread" />
      <item value="Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method." />
      <item value="don't retain ref while waiting" />
      <item value="he wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A &quot;status&quot; field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait." />
      <item value="Base of synchronization control for this lock. Subclassed into fair and nonfair versions below. Uses AQS state to represent the number of holds on the lock." />
      <item value="ase of synchronization control for this lock. Subclassed into fair and nonfair versions below. Uses AQS state to represent the number of holds on the lock." />
      <item value="Acquires the lock unless the current thread is interrupted. Acquires the lock if it is available and returns immediately." />
      <item value="Local cache impliment, load the black or white list from local" />
      <item value="A MsgPack of kryo Serializer for redis" />
      <item value="Availability RedisCache handler, the redis operator" />
      <item value="A kryo Serializer for redis" />
      <item value="Token Bucket" />
    </histories>
  </component>
  <component name="Settings">
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5c565298cc6d41a2" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>