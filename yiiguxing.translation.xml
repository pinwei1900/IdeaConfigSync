<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="AUTO" />
    <option name="maxHistorySize" value="30" />
    <histories>
      <item value="nothing was read. release the buffer." />
      <item value="DEFAULT MAX COMPONENTS" />
      <item value="expand Nio Buffer Array" />
      <item value="The maximum amount of buffers that will be added to the return value." />
      <item value="write Spin Count" />
      <item value="The number of bytes, possibly zero, that were actually transferred" />
      <item value="Check for null as it may be set to null if the channel is closed already" />
      <item value="Mark all pending write requests as failure if the channel is inactive." />
      <item value="Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write" />
      <item value="Process OP_WRITE first as we may be able to write some queued buffers and so free memory." />
      <item value="We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise // the NIO JDK channel implementation may throw a NotYetConnectedException." />
      <item value="Request to write a message via this ChannelHandlerContext through the ChannelPipeline. This method will not request to actual flush, so be sure to call flush() once you want to request to flush all pending data to the actual transport." />
      <item value="Was cancelled so make sure we free up memory and notify about the freed bytes" />
      <item value="(Transport implementors only) an internal data structure used by AbstractChannel to store its pending outbound write requests. All methods must be called by a transport implementation from an I/O thread, except the following ones:" />
      <item value="true if and only if successfully marked this future as uncancellable or it is already done without being cancelled. false if this future has been cancelled already." />
      <item value="// There is no need to process all entries if there was already a flush before and no new messages // where added in the meantime." />
      <item value="Add a flush to this ChannelOutboundBuffer. This means all previous added messages are marked as flushed and so you will be able to handle them." />
      <item value="// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead // to a spin loop" />
      <item value="Process OP_WRITE first as we may be able to write some queued buffers and so free memory" />
      <item value="// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise // the NIO JDK channel implementation may throw a NotYetConnectedException." />
      <item value="We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise" />
      <item value="Set key to hold the string value if key is absent." />
      <item value="Set time to live for given key.." />
      <item value="the // executeEpollInReadyRunnable could read nothing, and if the user doesn't explicitly call read they will // never get data after this." />
      <item value="We must set the read flag here as it is possible the user didn't read in the last read loop," />
      <item value="/ Only fire a channelActive if the channel has never been registered. This prevents firing // multiple channel actives if the channel is deregistered and re-registered." />
      <item value="/ This must happen outside of the synchronized(...) block as otherwise handlerAdded(...) may be called while // holding the lock and so produce a deadlock if handlerAdded(...) will try to add another handler from outside // the EventLoop." />
      <item value="// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the // user may already fire events through the pipeline in the ChannelFutureListener." />
      <item value="check if the channel is still open as it could be closed in the mean time when the register // call was outside of the eventLoop" />
      <item value="Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor." />
    </histories>
  </component>
  <component name="Settings">
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5c565298cc6d41a2" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>