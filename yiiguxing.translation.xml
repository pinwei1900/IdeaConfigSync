<application>
  <component name="AppStorage">
    <option name="lastSourceLanguage" value="AUTO" />
    <option name="lastTargetLanguage" value="AUTO" />
    <option name="maxHistorySize" value="30" />
    <histories>
      <item value="Add the specified member having the specifeid score to the sorted set stored at key. If member is already a member of the sorted set the score is updated, and the element reinserted in the right position to ensure sorting. If key does not exist a new sorted set with the specified member as sole member is crated. If the key exists but does not hold a sorted set value an error is returned." />
      <item value="If the key does not exist null is returned. If the value stored at key is not a string an error is returned because GET can only handle string values." />
      <item value="label" />
      <item value="profile" />
      <item value="find Results" />
      <item value="find Result Count" />
      <item value="update Specify" />
      <item value="means nesting-related" />
      <item value="Metric Support" />
      <item value="Asserts that an object isn't null. If it is an AssertionError is thrown with the given message." />
      <item value="Management endpoint context-path." />
      <item value="This method executes the given closure against the RepositoryHandler for this project. The RepositoryHandler is passed to the closure as the closure's delegate." />
      <item value="Sorting a list of lists according to length of sublists" />
      <item value="length Recursive" />
      <item value="second Last Recursion" />
      <item value="last Recursive" />
      <item value="complement" />
      <item value="run Only Once Guard" />
      <item value="DIRECT" />
      <item value="Pavani Diwanji" />
      <item value="Each message is routed from one machine to * another based solely on information contained within that packet. * Multiple packets sent from one machine to another might be routed * differently, and might arrive in any order. Packet delivery is * not guaranteed." />
      <item value="connectionless" />
      <item value="represents" />
      <item value="Big Decimal" />
      <item value="Exclusive" />
      <item value="get Exclusive Owner Thread" />
      <item value="Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method." />
      <item value="don't retain ref while waiting" />
      <item value="he wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A &quot;status&quot; field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait." />
      <item value="Base of synchronization control for this lock. Subclassed into fair and nonfair versions below. Uses AQS state to represent the number of holds on the lock." />
    </histories>
  </component>
  <component name="Settings">
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="5c565298cc6d41a2" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>